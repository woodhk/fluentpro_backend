name: Deployment Pipeline

on:
  push:
    branches:
      - main
      - develop
    tags:
      - 'v*'
  workflow_dispatch:
    inputs:
      environment:
        description: 'Environment to deploy to'
        required: true
        default: 'staging'
        type: choice
        options:
        - staging
        - production
      force_deploy:
        description: 'Force deployment even if CI checks fail'
        required: false
        type: boolean
        default: false

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  # Determine deployment environment and strategy
  setup:
    runs-on: ubuntu-latest
    name: Setup Deployment
    outputs:
      environment: ${{ steps.env.outputs.environment }}
      image_tag: ${{ steps.env.outputs.image_tag }}
      deploy_staging: ${{ steps.env.outputs.deploy_staging }}
      deploy_production: ${{ steps.env.outputs.deploy_production }}
    
    steps:
    - name: Determine environment
      id: env
      run: |
        # Determine environment based on trigger
        if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
          ENVIRONMENT="${{ github.event.inputs.environment }}"
        elif [ "${{ github.ref }}" = "refs/heads/main" ] || [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          ENVIRONMENT="production"
        elif [ "${{ github.ref }}" = "refs/heads/develop" ]; then
          ENVIRONMENT="staging"
        else
          ENVIRONMENT="staging"
        fi
        
        # Determine image tag
        if [[ "${{ github.ref }}" == refs/tags/v* ]]; then
          IMAGE_TAG="${{ github.ref_name }}"
        elif [ "${{ github.ref }}" = "refs/heads/main" ]; then
          IMAGE_TAG="latest"
        else
          IMAGE_TAG="${{ github.sha }}"
        fi
        
        echo "environment=${ENVIRONMENT}" >> $GITHUB_OUTPUT
        echo "image_tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
        echo "deploy_staging=$([[ ${ENVIRONMENT} == "staging" ]] && echo true || echo false)" >> $GITHUB_OUTPUT
        echo "deploy_production=$([[ ${ENVIRONMENT} == "production" ]] && echo true || echo false)" >> $GITHUB_OUTPUT
        
        echo "ðŸŽ¯ Target Environment: ${ENVIRONMENT}"
        echo "ðŸ·ï¸  Image Tag: ${IMAGE_TAG}"

  # Build and push container images
  build:
    runs-on: ubuntu-latest
    name: Build & Push Images
    needs: setup
    permissions:
      contents: read
      packages: write
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3
      
    - name: Log in to Container Registry
      uses: docker/login-action@v3
      with:
        registry: ${{ env.REGISTRY }}
        username: ${{ github.actor }}
        password: ${{ secrets.GITHUB_TOKEN }}
        
    - name: Extract metadata
      id: meta
      uses: docker/metadata-action@v5
      with:
        images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
        tags: |
          type=ref,event=branch
          type=ref,event=pr
          type=semver,pattern={{version}}
          type=semver,pattern={{major}}.{{minor}}
          type=raw,value=${{ needs.setup.outputs.image_tag }}
          
    - name: Build and push production image
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./Dockerfile
        push: true
        tags: ${{ steps.meta.outputs.tags }}
        labels: ${{ steps.meta.outputs.labels }}
        build-args: |
          REQUIREMENTS_FILE=requirements/production.txt
          BUILD_ENV=production
        cache-from: type=gha
        cache-to: type=gha,mode=max
        
    - name: Build and push development image
      if: needs.setup.outputs.environment == 'staging'
      uses: docker/build-push-action@v5
      with:
        context: .
        file: ./docker/Dockerfile.dev
        push: true
        tags: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:dev-${{ needs.setup.outputs.image_tag }}
        build-args: |
          REQUIREMENTS_FILE=requirements/development.txt
          BUILD_ENV=development
        cache-from: type=gha
        cache-to: type=gha,mode=max

  # Deploy to staging environment
  deploy-staging:
    runs-on: ubuntu-latest
    name: Deploy to Staging
    needs: [setup, build]
    if: needs.setup.outputs.deploy_staging == 'true'
    environment:
      name: staging
      url: https://staging-api.fluentpro.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Setup deployment tools
      run: |
        # Install deployment tools
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        
    - name: Configure staging deployment
      run: |
        # Create staging environment file
        cat > .env.staging << EOF
        DJANGO_SETTINGS_MODULE=config.settings.staging
        SECRET_KEY=${{ secrets.STAGING_SECRET_KEY }}
        DB_NAME=${{ secrets.STAGING_DB_NAME }}
        DB_USER=${{ secrets.STAGING_DB_USER }}
        DB_PASSWORD=${{ secrets.STAGING_DB_PASSWORD }}
        DB_HOST=${{ secrets.STAGING_DB_HOST }}
        DB_PORT=${{ secrets.STAGING_DB_PORT }}
        REDIS_PASSWORD=${{ secrets.STAGING_REDIS_PASSWORD }}
        AUTH0_DOMAIN=${{ secrets.STAGING_AUTH0_DOMAIN }}
        AUTH0_CLIENT_ID=${{ secrets.STAGING_AUTH0_CLIENT_ID }}
        AUTH0_CLIENT_SECRET=${{ secrets.STAGING_AUTH0_CLIENT_SECRET }}
        SUPABASE_URL=${{ secrets.STAGING_SUPABASE_URL }}
        SUPABASE_ANON_KEY=${{ secrets.STAGING_SUPABASE_ANON_KEY }}
        SUPABASE_SERVICE_KEY=${{ secrets.STAGING_SUPABASE_SERVICE_KEY }}
        OPENAI_API_KEY=${{ secrets.STAGING_OPENAI_API_KEY }}
        EOF
        
    - name: Deploy with Docker Compose
      run: |
        # Copy production compose and modify for staging
        cp docker/docker-compose.prod.yml docker-compose.staging.yml
        
        # Update image references
        sed -i "s|build:|image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.setup.outputs.image_tag }}|g" docker-compose.staging.yml
        
        # Deploy to staging server
        echo "ðŸš€ Deploying to staging environment..."
        # Note: In a real setup, you would SSH to staging server or use container orchestration
        # docker-compose -f docker-compose.staging.yml --env-file .env.staging up -d
        
    - name: Run database migrations
      run: |
        echo "ðŸ”„ Running database migrations on staging..."
        # In real deployment:
        # docker-compose -f docker-compose.staging.yml exec web python manage.py migrate
        
    - name: Run health checks
      run: |
        echo "ðŸ” Running post-deployment health checks..."
        # Health check implementation would go here
        # curl -f https://staging-api.fluentpro.com/api/health/
        
    - name: Notify deployment success
      run: |
        echo "âœ… Staging deployment completed successfully!"
        echo "ðŸŒ Staging URL: https://staging-api.fluentpro.com"

  # Deploy to production environment
  deploy-production:
    runs-on: ubuntu-latest
    name: Deploy to Production
    needs: [setup, build]
    if: needs.setup.outputs.deploy_production == 'true'
    environment:
      name: production
      url: https://api.fluentpro.com
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Require manual approval for production
      uses: trstringer/manual-approval@v1
      if: github.event.inputs.force_deploy != 'true'
      with:
        secret: ${{ github.TOKEN }}
        approvers: ${{ secrets.PRODUCTION_APPROVERS }}
        minimum-approvals: 2
        issue-title: "Production Deployment Approval Required"
        issue-body: |
          **Production Deployment Request**
          
          ðŸŽ¯ **Environment:** Production
          ðŸ·ï¸ **Version:** ${{ needs.setup.outputs.image_tag }}
          ðŸ“¦ **Image:** ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.setup.outputs.image_tag }}
          ðŸ‘¤ **Triggered by:** ${{ github.actor }}
          ðŸ”— **Workflow:** ${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}
          
          **Changes:**
          ${{ github.event.head_commit.message }}
          
          Please review and approve this production deployment.
          
    - name: Setup production deployment tools
      run: |
        # Install production deployment tools
        curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
        chmod +x kubectl
        sudo mv kubectl /usr/local/bin/
        
        # Install Helm
        curl https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 | bash
        
    - name: Configure production deployment
      run: |
        # Create production environment file
        cat > .env.production << EOF
        DJANGO_SETTINGS_MODULE=config.settings.production
        SECRET_KEY=${{ secrets.PRODUCTION_SECRET_KEY }}
        DB_NAME=${{ secrets.PRODUCTION_DB_NAME }}
        DB_USER=${{ secrets.PRODUCTION_DB_USER }}
        DB_PASSWORD=${{ secrets.PRODUCTION_DB_PASSWORD }}
        DB_HOST=${{ secrets.PRODUCTION_DB_HOST }}
        DB_PORT=${{ secrets.PRODUCTION_DB_PORT }}
        REDIS_PASSWORD=${{ secrets.PRODUCTION_REDIS_PASSWORD }}
        AUTH0_DOMAIN=${{ secrets.PRODUCTION_AUTH0_DOMAIN }}
        AUTH0_CLIENT_ID=${{ secrets.PRODUCTION_AUTH0_CLIENT_ID }}
        AUTH0_CLIENT_SECRET=${{ secrets.PRODUCTION_AUTH0_CLIENT_SECRET }}
        SUPABASE_URL=${{ secrets.PRODUCTION_SUPABASE_URL }}
        SUPABASE_ANON_KEY=${{ secrets.PRODUCTION_SUPABASE_ANON_KEY }}
        SUPABASE_SERVICE_KEY=${{ secrets.PRODUCTION_SUPABASE_SERVICE_KEY }}
        OPENAI_API_KEY=${{ secrets.PRODUCTION_OPENAI_API_KEY }}
        SENTRY_DSN=${{ secrets.PRODUCTION_SENTRY_DSN }}
        EOF
        
    - name: Backup production database
      run: |
        echo "ðŸ’¾ Creating production database backup..."
        # Database backup implementation would go here
        # pg_dump or equivalent backup command
        
    - name: Deploy with zero-downtime strategy
      run: |
        echo "ðŸš€ Deploying to production with zero-downtime strategy..."
        
        # Update image references in production compose
        cp docker/docker-compose.prod.yml docker-compose.production.yml
        sed -i "s|build:|image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ needs.setup.outputs.image_tag }}|g" docker-compose.production.yml
        
        # Blue-green or rolling deployment strategy would be implemented here
        # This is a simplified example
        
    - name: Run database migrations
      run: |
        echo "ðŸ”„ Running database migrations on production..."
        # Production migration with safety checks
        # docker-compose -f docker-compose.production.yml exec web python manage.py migrate --check
        # docker-compose -f docker-compose.production.yml exec web python manage.py migrate
        
    - name: Warm up application
      run: |
        echo "ðŸ”¥ Warming up application..."
        # Application warm-up requests to improve initial response times
        
    - name: Run comprehensive health checks
      run: |
        echo "ðŸ” Running comprehensive health checks..."
        # Comprehensive health checks for production
        # curl -f https://api.fluentpro.com/api/health/
        # curl -f https://api.fluentpro.com/api/health/database/
        # curl -f https://api.fluentpro.com/api/health/cache/
        
    - name: Update monitoring and alerting
      run: |
        echo "ðŸ“Š Updating monitoring configuration..."
        # Update monitoring dashboards, alerts, etc.
        
    - name: Notify deployment success
      run: |
        echo "âœ… Production deployment completed successfully!"
        echo "ðŸŒ Production URL: https://api.fluentpro.com"
        
        # Send notifications to team
        # Slack, email, or other notification systems

  # Rollback capability
  rollback:
    runs-on: ubuntu-latest
    name: Emergency Rollback
    if: failure() && (needs.deploy-staging.result == 'failure' || needs.deploy-production.result == 'failure')
    needs: [setup, deploy-staging, deploy-production]
    environment:
      name: ${{ needs.setup.outputs.environment }}
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Rollback deployment
      run: |
        echo "ðŸ”„ Initiating emergency rollback..."
        
        # Get previous stable version
        PREVIOUS_TAG=$(git describe --tags --abbrev=0 HEAD~1)
        echo "Rolling back to: ${PREVIOUS_TAG}"
        
        # Rollback implementation would go here
        # docker-compose down && docker-compose up -d with previous image
        
    - name: Verify rollback
      run: |
        echo "âœ… Rollback completed, verifying system health..."
        # Health checks after rollback
        
    - name: Notify rollback
      run: |
        echo "ðŸš¨ Emergency rollback completed!"
        # Send urgent notifications about rollback

  # Post-deployment verification
  post-deploy:
    runs-on: ubuntu-latest
    name: Post-Deployment Verification
    needs: [setup, deploy-staging, deploy-production]
    if: always() && (needs.deploy-staging.result == 'success' || needs.deploy-production.result == 'success')
    
    steps:
    - name: Run integration tests
      run: |
        echo "ðŸ§ª Running post-deployment integration tests..."
        # Integration tests against deployed environment
        
    - name: Performance benchmarks
      run: |
        echo "âš¡ Running performance benchmarks..."
        # Performance testing against deployed environment
        
    - name: Update deployment status
      run: |
        echo "ðŸ“ Updating deployment status..."
        # Update deployment tracking systems
        
        echo "ðŸŽ‰ Deployment pipeline completed successfully!"
        echo "Environment: ${{ needs.setup.outputs.environment }}"
        echo "Version: ${{ needs.setup.outputs.image_tag }}"